База знаний
====================================================

Вопросы собраны из разных источников интернета. Добавляйте свои


## <a name='toc'>Table of Contents</a>

  1. [SRE](#sre)
  2. [Мониторинг](#monitoring)
  1. [Разработка и тестирование](#general)
  1. [Базовые вопросы](#simple)
  1. [Вопросы по Linux системе](#system)
  1. [Hard Linux Questions](#hard)
  1. [Expert Linux Questions](#expert)
  1. [Общие вопросы по системам](#mysql)
  1. [DevOps Questions](#devop)
  2. [CICD Questions](#cicd)
  1. [Вопросы по Docker'у](#docker)
  2. [Вопросы по Kubernetes-Openshift](#openshift)
  1. [Вопросы по Elastic'у](#elk)
  1. [Веселые вопросы](#fun)
  1. [Сетевые вопросы](#web)
  1. [Практикум](#demo)
  1. [Команды](#commands)
  1. [Other Great References](#references)

#### [[⬆]](#toc) <a name='sre'>SRE:</a>

<details>
    <summary>В чем разница между SRE и DevOps?</summary><br> 
    Главное отличие между DevOps и SRE (Site Reliability Engineering) заключается в том, что DevOps — это широкая философия и культура сотрудничества, а SRE — это конкретный, основанный на инженерных практиках подход к реализации целей DevOps. SRE можно рассматривать как конкретную реализацию принципов DevOps от компании Google <br> 
 </details>  
<details>
    <summary>Что такое бюджет ошибок (error budget)?</summary><br> 
     Это заранее согласованный, количественный показатель допустимого уровня ненадежности (простоев, ошибок, низкой производительности) для сервиса в течение определенного периода времени. <br> 
 </details>  
<details>
    <summary>Что такое Service Level Indicator (SLI)?</summary><br> 
    Service Level Indicator (SLI) – это количественная оценка работы сервиса, связанная с удовлетворенностью пользователей производительностью приложения или сервиса за заданный период времени (месяц, квартал, год). <br>      Это индикатор пользовательского опыта, который отслеживает одну из многочисленных возможных метрик  и представляется в процентном эквиваленте, где 100 % - означает отличный пользовательский опыт, а 0% - ужасный. <br>      Чтобы точно собирать и отслеживать SLI, компаниям необходимо измерять поведение на стороне клиента, а не на стороне сервера.<br>
    Slips - это показатели, которые вносят вклад в SLI обычно измеряются в процентах, где 0% означает ужасную производительность, а 100% - идеальную.<br>
 </details> 
 <details>
    <summary>Что такое Service Level Objectives (SLO)?</summary><br> 
    <b>Service Level Objectives (SLO) – ориентир, используемыми компанией для измерения уровня обслуживания клиентов и пользователей. При установке SLO необходимо указывать реально достижимое значение для каждого конкретного SLI. SLO – это наш внутренний показатель качества работы сервиса и/или приложения. В концепции SLI и SLO присутствует индикатор Error Budget «право на ошибку». Error Budget – это степень невыполнения наших SLO. Например, если наш SLO учитывает доступность, то error budget – это максимальное время, в течение которого система может быть недоступной без последствий для команды сопровождения.</b><br> 
 </details> 
 
 <details>
    <summary>Что такое Постмортем?</summary><br> 
    <b>Постмортем — документ, где вы описываете инцидент, его разрешение и меры, которые можно принять, чтобы такого больше не повторилось.(поиск root cause)</b><br> 
 </details>
 
 * <b>Какие виды балансировки поддерживает Nginx? </b><br>
  Round-robin. Веб-сервер по умолчанию распределяет запросы равномерно между бэкендами (но с учетом весов). <br>
  Least_conn. Запросы сначала отправляются бэкенду с наименьшим количеством активных подключений (но с учетом весов).<br>
  Hash и IP-hash. При помощи этого метода можно создать своего рода постоянные соединения между клиентами и бэкендами.<br>
* <b>Что означает директива upstream в настройках nginx'a? </b><br>
  Данная директива включает балансировку нагрузки. По умолчанию, соединения распределяются по серверам циклически (в режиме round-robin) с учётом весов серверов.<br>  



#### [[⬆]](#toc) <a name='monitoring'>Мониторинг</a>

<details>
    <summary>Чем отличается Zabbix от Promethous?</summary><br> 
    Zabbix – это комплексное универсальное решение, включающее сбор данных, оповещение и визуализацию, подходящее для широкого спектра инфраструктур, но менее гибкое в динамических средах<br>  
    Prometheus – это система для сбора и хранения временных рядов метрик, ориентированная на DevOps и контейнерные технологии, требующая сторонних инструментов для визуализации(Grafana)<br>  
</details>  
<details>
    <summary>Как Promethous собирает метрики?</summary><br> 
    Prometheus собирает метрики, используя механизм «pull», при котором сервер Prometheus периодически запрашивает (по HTTP) числовые данные с целевых объектов (targets). <br>  
    Эти объекты должны предоставлять метрики в специальном формате через HTTP-эндпоинты, обычно /metrics. <br>  
    Собранные данные сохраняются в базе данных временных рядов. Для сценариев, где механизм «pull» не подходит (например, пакетные задания), используется Pushgateway, <br>  
    который позволяет приложениям отправлять метрики в Prometheus через промежуточный шлюз. <br>  
 </details>  


#### [[⬆]](#toc) <a name='general'>Разработка и тестирование </a>

<details>
    <summary>Машинный код</summary><br> 
      Машинный код — это низкоуровневый язык программирования, состоящий из двоичных инструкций (нули и единицы), которые центральный процессор компьютера может выполнять напрямую. Он является основой для всего программного обеспечения и состоит из последовательности машинных команд, определяя какие операции должен выполнить процессор и в каком порядке. <br>
 </details>
<details>
    <summary>ООП концепты</summary><br>
       Кроссплатформенность: программа на Java может быть запущена на любой платформе без каких-либо изменений. Единственное, что нужно — установленная JVM (java virtual machine).<br>
       Высокая производительность: JIT(Just In Time compiler) позволяет высокую производительность. JIT конвертирует байт-код в машинный код и потом JVM стартует выполнение.<br>
       Мультипоточность: поток выполнения, известный как Thread. JVM создает thread, который называется main thread. Программист может создать несколько потоков наследованием от класса Thread или реализуя интерфейс Runnable.<br>
       Наследование - один класс может наследовать("extends") другой класс.<br>
       Инкапсуляция - связывание данных (переменных, полей) и функций (методов) в единый компонент — класс или объект, а также сокрытие реализации при помощи модификаторов доступа, при помощи геттеров и сеттеров. <br>
       Полиморфизм - Суть полиморфизма заключается в возможности использовать один и тот же интерфейс, метод или оператор для работы с объектами разных классов, которые имеют общую основу (наследуются от общего родителя или реализуют общий интерфейс).<br>
       Абстракция - Абстракция означает «скрытие сложности за простым интерфейсом», позволяет создавать модель реального мира, представляя объекты в упрощенном виде, который достаточен для решения конкретной задачи.<br>
 </details>
<details>
    <summary>Как работает JVM(Java Virtual Machine)? </summary><br> 
       Работа JVM — многоступенчатый процесс, который позволяет Java-программам работать на любой операционной системе или аппаратной платформе, где установлена JVM.<br> 
       JVM — это абстрактный слой между вашей программой и операционной системой/аппаратным обеспечением.<br>
       Ключевые компоненты, помимо выполнения:<br>
       Управление памятью (Memory Management): JVM управляет кучей (Heap) для объектов и стеком (Stack) для вызовов методов.<br>
       Сборщик мусора (Garbage Collector, GC): Автоматически освобождает память, занятую объектами, которые больше не используются приложением, избавляя разработчика от ручного управления памятью.<br>
 </details>
<details>
    <summary>Объясните процесс преобразования байт-кода в машинный код.</summary><br> 
       Процесс от исходного кода до выполнения выглядит так: Исходный код (.java) -> Байт-код (.class) -> Машинный код -> Выполнение.<br>
 </details>
<details>
    <summary>Компиляция в Байт-код</summary><br> 
       Результатом этой компиляции является байт-код (bytecode), который сохраняется в .class файлах. Байт-код — это универсальный, платформенно-независимый набор инструкций, который понимает только JVM.<br>
 </details>
<details>
    <summary>Компиляция в Байт-код</summary><br> 
       Результатом этой компиляции является байт-код (bytecode), который сохраняется в .class файлах. Байт-код — это универсальный, платформенно-независимый набор инструкций, который понимает только JVM.<br>
 </details>
<details>
    <summary>Запуск и Загрузка JVM</summary><br> 
       Когда вы запускаете Java-приложение (командой java ClassName), происходит следующее:<br>
       Загрузка классов : JVM использует специальный загрузчик(Class Loader), чтобы найти и загрузить необходимые .class файлы (как вашего приложения, так и стандартных библиотек Java) в память.<br>
       Проверка байт-кода (Bytecode Verifier): Загруженный байт-код проверяется на безопасность и корректность, чтобы гарантировать, что он не нарушает правила JVM и не повредит систему.<br>
       Выполнение (Execution Engine): На этом этапе начинается основная работа — преобразование байт-кода в инструкции, понятные конкретному процессору (машинный код).<br>
 </details>
<details>
    <summary>Преобразование Байт-кода в Машинный код (Execution Engine)</summary><br> 
       Изначально байт-код выполняется интерпретатором. Он читает по одной инструкции байт-кода за раз и немедленно выполняет соответствующую операцию на целевой платформе<br>
       Далее подхватывает JIT-компилятор(JIT работает параллельно с интерпретатором). JIT-компилятор отслеживает, какие части кода (методы, циклы) выполняются чаще всего. Эти участки называются "горячими точками" (hot spots). <br>
Компиляция: Когда JIT определяет "горячую точку", он компилирует этот байт-код целиком в оптимизированный машинный код (нативный код) для конкретной аппаратной платформы.<br>
Кэширование и выполнение: Полученный машинный код кэшируется (сохраняется в памяти). В следующий раз, когда этот же участок кода потребуется выполнить, JVM использует уже готовый, быстрый машинный код вместо медленной интерпретации.<br>
</details>
<details>
    <summary>Каким способом можно диагностировать работу java-приложения?</summary><br> 
       Инструменты командной строки (Встроенные JDK Tools), графические интерфейсы(JConsole), АРМ-системы, анализ логов<br> 
 </details>  
<details>
    <summary>Какие инструменты тестирования программного обеспечения вы использовали?</summary><br> 
    Telerik, Selenium.<br> 
 </details>



#### [[⬆]](#toc) <a name='simple'>Базовые вопросы:</a>

<details>
    <summary>Как подключится к удаленному серверу через SSH?</summary><br> 
    ```ssh login@remote_server_ip``` <br>
 </details>  
* <b>Какие типы файлов вы знаете в ОС Linux?</b> <br>  
* <b>What is SMTP? Give the basic scenario of how a mail message is delivered via SMTP.</b>
* <b>What is RAID? What is RAID0, RAID1, RAID5, RAID10?</b>
* What is a level 0 backup? What is an incremental backup?
* Describe the general file system hierarchy of a Linux system.
* Which difference have between public and private SSH key?
  
* <b>Как посмотреть переменные среды и как их использовать?</b><br>
  ```printenv / env```<br>
  Переменные можно использовать в скриптах  <br>
* <b>Когда запускаете ```ifconfig -a``` получаете ошибку "command not found". С чем это может быть связано?</b><br>
  Пакет net-tools не установлен, или отсутствует путь до каталога /sbin в переменных среды. <br>
  Запускайте, указывая, полный путь: <b>/sbin/ifconfig -a</b><br>
* <b>Какой командой можно изменить владельца файла? Установить разрешения на файл?</b><br />
  ```chown; chmod ```<br>
* <b>Что выполнит данная команда ```chmod +x FILENAME```?</b><br />
  Добавит разрешение на запуск файла<br>
* <b>Что означают разрешение 0750 для файла? Отличается от разрешений для директории?</b><br />
  Владелец имеет полные права доступа, группы - чтение и запись, остальные пользователи - не имеют доступа.<br> 
  Не отличается<br> 
* <b>Как добавить нового юзера без разрешения на логин(login permissions)?</b><br />
  ```useradd -r newuser --shell=/sbin/nologin ```<br>
* <b>Как добавить/удалить пользователя из группы?</b><br>
  ```usermod -aG somegroup user```<br>
  ```deluser user group``` <br>
* <b>Что выполнит данная команда CTRL-c?</b><br>
  Отправит сигнал SIGINT, который завершит процесс <br>
* <b>Что находится в файле /etc/services?</b><br>
  Файл описывает соответствие службы и порта<br>
* <b>Как перенаправить стандартный вывод STDOUT и стандартный вывод ошибок STDERR? (> /dev/null 2>&1)</b><br>
  Направить стандартный поток вывода и стандартный поток ошибок в файл: <br />
  ```some_command &gt; file.log 2&gt;&amp;1 ```<br />
  Направить стандартный поток ошибок в файл:<br>
  <b>some_command &gt; file.log 2&gt; file.err</b><br />
* <b>Какая разница между подключением по Telnet и SSH?</b><br />
  ssh использует шифрование<br />
* <b>Назовите опции в нижнем регистре для команды ```ls```, которые не являются рабочими. </b><br />
  ```х; у``` <br />
* <b>Что такое модуль ядра Linux'a? </b> <br />
  loadable kernel module, LKM — объект, содержащий код, который расширяет функциональность запущенного (базового) ядра ОС. <br />
* <b>Что такое протокол ICMP? Для чего используется?</b><br />
  Протокол межсетевых управляющих сообщений<br>
  Используется для передачи сообщений об ошибках и других исключительных ситуациях, возникших при передаче данных<br>
* <b>Что такое уровень запуска и как посмотреть текущий?</b><br />
  Нумерованный режим функционирования операционной системы, определяет какие функции будут загружены в ОС. Чем выше уровень - тем больше функций. <br />
  <b>runlevel</b> <br />
* <b>Объясните, что выполнит данная команда echo "1" > /proc/sys/net/ipv4/ip_forward </b><br />
  Команда включает IP Forwarding<br>
* <b>В чем разница между процессом и потоком?</b><br />
  Процесс — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память).<br />
  Поток — определенный способ выполнения процесса. Когда один поток изменяет ресурс процесса, это изменение сразу же становится видно другим потокам этого процесса.<br>



#### [[⬆]](#toc) <a name='system'>Вопросы по Linux системе:</a>

<details>
    <summary><b>Как называется главный пользователь Linux системы и назовите его UID?</b><br></summary><br> 
      root, 0. <br> 
 </details>
<details>
    <summary>Какой процесс идет с пидом 0?</summary><br> 
    Этот процесс не выполняет никаких задач, он является бездействующим. Процессор переходит к выполнению процесса 0, когда нет других активных процессов для выполнения.<br />
 </details>
<details>
    <summary>Какой процесс идет с пидом 1?</summary><br> 
    Самый первый процесс при запуске системы получает пид 1(PID 1), так называемый инит(init)<br />
    Если этот процесс завершается по какой-либо причине, все остальные процессы тоже завершаются<br />
    Если завершается процесс, у которогое есть потомки, все потомки переходят(reparented) под процесс с пидом 1<br />
 </details>
<details>
    <summary>Модели процессора, количестве физических и логических ядер, поддерживаемых инструкциях, режиме работы?</summary><br> 
     Модель процессора cat /proc/cpuinfo или lscpu <br />
     Ядра физические и логические: <br />
     grep "cpu cores" /proc/cpuinfo |sort -u |cut -d":" -f2 <br />
     grep -c "processor" /proc/cpuinfo <br />
     Логические ядра - это число физических ядер, умноженное на количество потоков, которые могут выполняться на каждом ядре с помощью гиперпотока. например, мой 4-ядерный процессор запускает два потока на ядро, поэтому у меня есть 8 логических процессоров.<br />
</details>
<details>
  <summary>Как проверить является ли машина виртуальной?</summary><br> 
    С помощью команды <b>/proc/cpuinfo</b>, Linux добавляет в ответ флаг hypervisor <br />
    С помощью команды <b>virt-what</b> <br />
    С помощью команды <b>hostnamectl</b> <br />
</details>  
<details>
  <summary>Как принудительно заставить систему выполнить проверку файловой системы при следующем запуске?</summary><br> 
    Для этого нужно создать файл forcefsck в корневом разделе<br> 
    ```touch /forcefsck ```<br>
</details>  
<details>
  <summary>Какими командами можно посмотреть среднюю загрузку системы?</summary><br> 
    w; top; uptime;<br>
</details>
<details>
  <summary>Объясните load average</summary><br> 
   Load average — это метрика, показывающая среднюю нагрузку на систему за определённые периоды времени, обычно 1, 5 и 15 минут. Она отражает общее количество процессов, которые либо выполняются, либо ожидают своей очереди на выполнение (на процессор или на ввод-вывод). Понимание load average помогает оценить, насколько система загружена и справляется ли с текущими задачами. <br>
   Высокий Load Average может быть вызван двумя основными причинами: <br>
   Высокая загрузка ЦП (CPU-bound): Слишком много процессов требуют процессорного времени. <br>
   Высокая загрузка ввода/вывода (I/O-bound): Процессы простаивают в очереди, ожидая завершения операций диска или сети. <br>
   Низкий Load Average (LA) обычно является хорошим знаком, указывающим на то, что ваша система работает эффективно и имеет много свободных ресурсов.<br>
   Однако в некоторых ситуациях он может сигнализировать о скрытых проблемах или неэффективном использовании инфраструктуры.<br>
</details> 
<details>
  <summary>Как посмотреть утилизацию загрузки диска процессами(какой процесс использует диск по максимому)?</summary><br> 
    Для просмотра утилизации диска процессами в Linux существует специализированная утилита под названием iotop. Она работает аналогично команде top, но фокусируется на операциях ввода-вывода (I/O) диска.<br>
</details>
<details>
  <summary>Что обозначает ```&``` после команды?</summary><br> 
    Амперсанд переводит выполнение команды терминала в фоновый режим(background). <br>
</details>   
<details>
  <summary>Что обозначает ```& disown``` после команды?</summary><br> 
     & disown переводит выполнение команды в фоновый реджим и "отвязывает" терминал от выполняемого процесса(disown удаляет задачу из списка задач оболочки). <br>
</details>
<details>
  <summary>Что такое фильтр пакетов (packet filter) и как он работает?</summary><br> 
     Фильтр пакетов - программа, которая просматривает заголовки пакетов по мере их поступления, и определяет дальнейшую судьбу всего пакета. Фильтр может сбросить (DROP) пакет или принять (ACCEPT) пакет или сделать с ним что-то еще более сложное. <br>
</details>  
<details>
  <summary>Что такое виртуальная память(Virtual Memory)?</summary><br> 
     Виртуальная память — технология управления памятью в операционных системах, которая позволяет программам использовать больше памяти, чем физически установлено в компьютере (RAM).<br>
     Создает иллюзию того, что у каждого процесса есть доступ к огромному, непрерывному адресному пространству, хотя на самом деле память фрагментирована и часть данных может храниться на диске. <br>
</details> 
<details>
  <summary>Что такое swap и для чего используется?</summary><br> 
     SWAP(своп)—механизм виртуальной памяти, при котором часть данных из оперативной памяти перемещается на хранение на жёсткий диск. В Linux оперативная память делится на разделы, называемые страницами (pages). <br>           Swapping(подкачка) – процесс во время которого страницы памяти копируются на специально сконфигурированный для этого раздел диска(swap space) для освобождения ОЗУ. <br>
</details>   
<details>
  <summary>Что такое "sticky bit"?</summary><br> 
      Sticky bit используется в основном для каталогов, чтобы защитить в них файлы. Если установлен sticky bit, только владелец файла или каталога и суперпользователь (root) могут удалять или переименовывать файлы в этом каталоге<br>
</details>
<details>
  <summary>Объясните термины suid, sgid</summary><br> 
     Setuid (Set User ID): При установке этого атрибута на исполняемый файл, процесс, запущенный с этого файла, будет работать от имени владельца файла, а не текущего пользователя.<br>
     Setgid (Set Group ID): Аналогично setuid, но процесс будет работать от имени группы файла. <br>
</details> 
<details>
  <summary>Для чего предназначен бит неизменяемости(immutable bit)?</summary><br> 
      Бит неизменяемости может быть назначен файлу, который размещён в расширенной файловой системе (Ext3, Ext4), для его защиты от изменений. "immutable bit" может быть добавлен к атрибутам файла с помощью программы chattr и только супер-пользователем. <br>
</details>  
<details>
  <summary>Что такое жесткая ссылка, символическая? Чем отличаются? Что произойдет если удалить источник, на который указывает ссылка?</summary><br> 
      Символическая ссылка(ярлык) - содержит адрес нужного файла в вашей файловой системе. Когда вы пытаетесь открыть такую ссылку, то открывается целевой файл или папка.  <br>
      При удалении источника ссылка указывает в никуда. <br>
      Жесткая ссылка непосредственно указывает на местоположение файла на жестком диске. Файл можно перемещать между каталогами, и все ссылки останутся рабочими, поскольку для них неважно имя. <br>
</details> 
<details>
  <summary>Что такое айнод(inode) и какие поля в нем хранятся?</summary><br> 
      Inode (индексный дескриптор) — структура данных в традиционных UNIX файловых системах(например, ext4). В этой структуре хранится метаинформация:названии, разрешениях, устройстве размещения, времени последнего доступа и тд. <br>
  Посмотреть можно командами: ls -i && stat filename <br>
</details>  
<details>
  <summary>Как уменьшить размер файла, который используется в текущий момент(например, файла лога)?</summary><br> 
     Используя команду truncate. Например, полностью очистить: truncate -s 0 file <br>
</details>
<details>
  <summary>Что такое переадресация SSH-порта?</summary><br> 
     Переадресация порта SSH создает безопасное соединение между удаленным компьютером, через который можно ретранслировать сервисы, и локальным компьютером, который выдает команды. Это также называется SSH-туннелированием и используется для передачи информации, которая не требует зашифрованного протокола. <br>
</details>
    
* <b>Как добавить пользователя без использования команд useradd/adduser?</b><br>
  Добавить запись в /etc/passwd<br>
  Добавить запись группы в /etc/group<br>
  Создать домашнюю директорию для пользователя<br>
  Установить пароль <br>
* <b>Опишите команду mknod и расскажите когда вы её используете?</b><br>
  Команда mknod используется для создания файлов устройств. Файлы устройств хранятся в каталоге /dev, и в отличие от обычных файлов, эти файлы устройств — те, о которых ядро знает, и которые читает или записывает в них. <br>
* <b>Загрузка диского пространства 100%, вы удалили огромный файл логов, но df показывает - нет свободного места. В чем проблема?</b><br>
  Какой-то процесс держит файл. С помощь lsof some.log определяем какие процессы не отпустили файл, завершаем их и файл удаляется.<br>
* <b>Вы получаете ошибку "filesystem is full", хотя 'df' говорит об обратном, место есть. В чем проблема?</b><br>
  Проверьте досутность inode, df -i. Возможно закончились айноды. <br>
* <b>Расскажите как работает команда 'ps'.</b><br>
  Команда ps работает путем чтения файлов в файловой системе proc. Каталог /proc/PID содержит различные файлы, содержащие информацию о PID'е процесса. <br>
  Содержимое этих файлов генерируется ядром на лету, когда процесс их считывает. <br>
* <b>Что происходит с дочерним процессом, который завершил свое выполнение, но у которого нет родительского процесса ожидающего его завершение? Почему это плохо?</b><br>
  Процесс при завершении освобождает все свои ресурсы и становится «зомби» — пустой записью в таблице процессов, хранящей код завершения для родительского процесса. Система уведомляет родительский процесс о завершении дочернего с помощью сигнала SIGCHLD. Предполагается, что после получения SIGCHLD он считает код возврата с помощью системного вызова wait(), после чего запись зомби будет удалена из списка процессов. Если родительский процесс игнорирует SIGCHLD, то зомби остаются до завершения родительского процесса. <br>
* <b>Кратко опишите каждое состояние процесса(process states) в ОС Linux.</b><br>
  Running состояние, в котором процесс либо запущен, либо готов к запуску.<br>
  Interruptible является заблокированным состоянием процесса, который ожидает события или сигнала от другого процесса<br>
  Uninterruptible. Процесс вынужден остановиться при определенном условии, т.к оборудование находится в состоянии ожидания и сигнал не может быть обработан.<br>
  Stopped возникает, когда процесс завершен. Этот процесс можно перезапустить.<br>
  Zombie в этом состоянии процесс будет завершен, и информация по-прежнему будет доступна в таблице процессов.<br>
* <b>Какими командами посмотреть общую информацию о системе? </b><br>
  lscpu - послная статистика о CPU. <br>
  fdisk -l все о дисках <br>
  memory - free -t -m <br>
* <b>В чем отличие /dev/zero и /dev/null?</b><br>
  Псевдоустройство /dev/null - это, своего рода, "черная дыра" в системе. Все, что записывается в этот файл, "исчезает" навсегда. <br>
  Псевдоустройство /dev/zero - специальный файл в UNIX-подобных системах, представляющий собой источник нулевых байтов (ASCII NUL, 0x00). При чтении этого файла никогда не достигается его конец.<br>
* What is the difference between exec and fork?
* What is "nohup" used for?
* What is the difference between these two commands?
 * ```myvar=hello```
 * ```export myvar=hello```
* How many NTP servers would you configure in your local ntp.conf?
* What does the column 'reach' mean in ```ntpq -p``` output?
* You need to upgrade kernel at 100-1000 servers, how you would do this?
* How can you get Host, Channel, ID, LUN of SCSI disk?
* How can you limit process memory usage?
* What is bash quick substitution/caret replace(^x^y)?
* Do you know of any alternative shells? If so, have you used any?
* What is a tarpipe (or, how would you go about copying everything, including hardlinks and special files, from one server to another)?
* How can you tell if the httpd package was already installed?
* How can you list the contents of a package?
* How can you determine which package is better: openssh-server-5.3p1-118.1.el6_8.x86_64 or openssh-server-6.6p1-1.el6.x86_64 ?
* Can you explain to me the difference between block based, and object based storage?
* What is MAJOR and MINOR numbers of special files?

#### [[⬆]](#toc) <a name='hard'>Hard Linux Questions:</a>
<details>
  <summary>Перенаправить ошибки (stderr) в тот же файл, что и обычный вывод (stdout):</summary><br> 
     <b>Современный синтаксис (Bash): команда &> all_output.log </b><br>
     <b>Старый синтаксис (работает везде): команда > all_output.log 2>&1</b><br>
</details>

* Как сбросить кэш оперативной памяти?
* What is a tunnel and how you can bypass a http proxy?
* What is the difference between IDS and IPS?
* What shortcuts do you use on a regular basis?
* What is the Linux Standard Base?
* What is an atomic operation?
* Your freshly configured http server is not running after a restart, what can you do?
* What kind of keys are in ~/.ssh/authorized_keys and what it is this file used for?
* I've added my public ssh key into authorized_keys but I'm still getting a password prompt, what can be wrong?
* Did you ever create RPM's, DEB's or solaris pkg's?
* What does ```:(){ :|:& };:``` do on your system?
* How do you catch a Linux signal on a script?
* Can you catch a SIGKILL?
* What's happening when the Linux kernel is starting the OOM killer and how does it choose which process to kill first?
* Describe the linux boot process with as much detail as possible, starting from when the system is powered on and ending when you get a prompt.
* What's a chroot jail?
* When trying to umount a directory it says it's busy, how to find out which PID holds the directory?
* What's LD_PRELOAD and when it's used?
* You ran a binary and nothing happened. How would you debug this?
* What are cgroups? Can you specify a scenario where you could use them?
* How can you remove/delete a file with file-name consisting of only non-printable/non-type-able characters?
* How can you increase or decrease the priority of a process in Linux?


#### [[⬆]](#toc) <a name='expert'>Expert Linux Questions:</a>
<details>
  <summary>Можно ли перенаправить вывод (stdout) в 2 файла?</summary><br> 
     <b>Для вывода данных одновременно в два (или более) файла в Linux используется команда tee. </b><br>
     <b>команда_источник | tee файл1.txt файл2.txt </b><br>
</details>

* A running process gets ```EAGAIN: Resource temporarily unavailable``` on reading a socket. How can you close this bad socket/file descriptor without killing the process?
* What do you control with swapiness?
* How do you change TCP stack buffers? How do you calculate it?
* What is Huge Tables? Why isn't it enabled by default? Why and when use it?
* What is LUKS? How to use it?


#### [[⬆]](#toc) <a name='mysql'>Общие вопросы по системам:</a>

* How do you DB create a user?
* How do you create a new postgres user?
* How do you provide privileges to a DB user?
* What is the difference between a "left" and a "right" join?
* Explain briefly the differences between InnoDB and MyISAM.
* Describe briefly the steps you need to follow in order to create a simple master/slave cluster.
* Why should you run "mysql_secure_installation" after installing MySQL?
* How do you check which jobs are running?
* How would you take a backup of a MySQL database?
* <b>Какие виды репликации существуют для БД Postgres?</b><br>
  Логическая репликация (logical или statement replication) выполняется на уровне sql-запросов.<br>
  Физическая (построчная или row-based) основана на записях, которые лежат в журнале транзакций.<br>
* <b>Как происходит репликация в MongoDB? </b><br>
* What does "./configure && make && make install" do?


#### [[⬆]](#toc) <a name='cicd'>CI | CD Questions:</a>

<details>
  <summary> Что такое Continuous Integration и Continuous Deployment?</summary><br> 
  Continuous Integration (CI) — это методология разработки, при которой разработчики часто (несколько раз в день) интегрируют изменения в основной репозиторий кода. При каждом таком изменении автоматически запускаются тесты для проверки корректности кода и обнаружения ошибок на ранних этапах.  <br> 
  Continuous Deployment (непрерывное развертывание) — это автоматизированный процесс, который идет после CI и автоматически развертывает каждую успешную сборку на производственные серверы и выпускает её для конечных пользователей без ручного вмешательства. <br> 
</details>
<details>
  <summary> В чем разница между Continuous Deployment и Continuous Delivery?</summary><br> 
  Основное различие между Continuous Delivery (непрерывной доставкой) и Continuous Deployment (непрерывным развертыванием) заключается в том, что при Delivery код готов к развертыванию в продакшн, но требуется ручное подтверждение для его выпуска, а при Deployment каждое изменение, прошедшее все тесты, автоматически и без вмешательства человека развертывается в производственную среду. Continuous Deployment — это более продвинутый этап, который идет дальше Continuous Delivery.  <br> 
</details>
<details>
  <summary> Опишите основные этапы CI/CD</summary><br> 
  Разработчик пишет код и фиксирует его в репозитории.<br> 
  CI-пайплайн запускается автоматически после каждого коммита - сборка и тестирование. <br> 
  Если сборка и тесты успешны, код проходит к этапам CD - подготовка к релизу и пред-промовое развертывание.<br> 
  При непрерывной доставке приложение готово к выпуску по запросу, а при непрерывном развёртывании выпускается автоматически на продакшн <br> 
</details>
<details>
  <summary>Что такое Jenkinsfile</summary><br> 
  Jenkinsfile — это текстовый файл конфигурации, который описывает весь конвейер Jenkins (CI/CD) с помощью предметно-ориентированного языка (DSL) на основе Groovy.<br> 
  Этот файл позволяет определить рабочие процессы автоматизации, такие как сборка, тестирование и развертывание программного обеспечения, в виде кода, что делает их версионируемыми и управляемыми<br> 
</details>


#### [[⬆]](#toc) <a name='devop'>DevOps Questions:</a>

<details>
  <summary>DevOps(Development и Operations, разработка и эксплуатация)</summary><br> 
  <b> Набор культурных практик, методологий и инструментов, направленных на повышение способности организации быстро и надежно доставлять приложения и услуги.
      Основная цель DevOps — сократить жизненный цикл разработки программного обеспечения и обеспечить непрерывную доставку ПО</b><br> 
</details>
<details>
  <summary>Какие стадии должны быть в любом пайплайне?</summary><br> 
  Любой пайплайн включает обязательные стадии, такие как lint (проверка кода), test (тестирование), build (сборка приложения) и deploy (развертывание), а также опциональные, такие как security scan (сканирование на уязвимости), integration test (интеграционное тестирование) и monitor (мониторинг), которые обеспечивают качество и стабильность программного продукта на всех этапах его жизненного цикла<br> 
</details>
<details>
  <summary>Как и где хранить build artifacts?</summary><br> 
  Build artifacts, которые представляют собой файлы, создаваемые в процессе сборки приложения, можно хранить в облачных или локальных системах управления версиями, таких как GitLab, GitHub, а также в специализированных репозиториях артефактов, таких как JFrog Artifactory или Nexus.<br> 
  Выбор места хранения зависит от инфраструктуры проекта и требований к доступу к артефактам<br> 
</details>
<details>
  <summary> Что такое GIT?</summary><br> 
  Система контроля версий. Преимущества использования VCS:<br> 
      Восстановить предыдущую версию файла<br> 
      Вернуть весь проект к более ранней версии<br> 
      Сравнивайте и отслеживайте изменения<br> 
      Определите изменения, которые могли вызвать проблему<br> 
 </details> 
 
<details>
  <summary> Что такое commit?</summary><br> 
  <b> В Git - это моментальный снимок вашего репозитория в определенный момент времени. Команда git commit сохранит все поэтапные изменения вместе с кратким описанием от пользователя в локальном репозитории.</b><br> 
 </details>

<details>
  <summary> Что такое merge?</summary><br> 
  <b> Merge - это способ снова собрать разветвленную историю воедино. Команда git merge позволяет вам взять независимые линии разработки (branch) и интегрировать их в единую ветку.</b><br> 
 </details>
  
<details>
  <summary> Каковы преимущества DevOps?</summary><br> 
  <b> Технические преимущества:
      * Непрерывная доставка программного обеспечения
      * Менее сложные проблемы для устранения
      * Более быстрое решение проблем
Преимущества для бизнеса:
      * Более быстрая доставка функций
      * Более стабильная операционная среда
      * Больше времени на добавление ценности (а не на исправление/поддержку)</b><br> 
 </details>
 
* What is a dynamically/statically linked file?

* What is puppet/chef/ansible used for?
* What is Nagios/Zenoss/NewRelic used for?
* What is Jenkins/TeamCity/GoCI used for?

* What is a virtual IP address? What is a cluster?
* How do you print all strings of printable characters present in a file?
* How do you find shared library dependencies?
* What is Automake and Autoconf?
* ./configure shows an error that libfoobar is missing on your system, how could you fix this, what could be wrong?
* What are the advantages/disadvantages of script vs compiled program?
* What's the relationship between continuous delivery and DevOps?
* What are the important aspects of a system of continuous integration and deployment?
* How would you enable network file sharing within AWS that would allow EC2 instances in multiple availability zones to share data?

#### [[⬆]](#toc) <a name='docker'>Вопросы по Docker'у</a>

<details>
  <summary>Что такое контейнер Docker?</summary><br> 
    Контейнер — исполняемый пакет программного обеспечения, содержащий все необходимое для запуска приложения, например, системные программы, библиотеки, код, среды исполнения и настройки<br> 
</details>
<details>
  <summary>Основные различия менжу Containers and VMs?</summary><br> 
    Основные различия между контейнерами (Containers) и виртуальными машинами (VMs) заключаются в их архитектуре и уровне изоляции. Контейнеры обеспечивают легковесную изоляцию на уровне операционной системы, а виртуальные машины предоставляют полную изоляцию на уровне аппаратного обеспечения.<br> 
</details>
<details>
  <summary>Назовите наиболее важные команды Docker</summary><br> 
      build, сборка образа для Docker<br> 
      create, создание нового контейнера<br> 
      kill. принудительная остановка контейнера<br> 
      dockerd, запуск сервиса Docker<br> 
      commit, создание нового образа из изменений в контейнере<br> 
 </details>
<details>
  <summary>Что такое пространства имен в Docker?</summary><br> 
    Пространства имен Docker — это технология обеспечения изолированных рабочих пространств, известная как контейнер. <br> 
    Как только контейнер запускается, создается набор пространств имен для этого контейнера. <br> 
    Они обеспечивают уровень изоляции для контейнеров, поскольку каждый контейнер работает в отдельном пространстве имен, с ограничением доступа к другим пространствам.<br> 
</details>
<details>
  <summary>Что такое образ Docker, что делает команда Docker run?</summary><br> 
  Образ Docker — это набор файлов, соединенный с настройками, с помощью которого можно создать экземпляры, которые запускаются в отдельных контейнерах в виде изолированных процессов. </span>
  Образ строится с использованием инструкций для получения полной исполняемой версии приложения, зависящей от версии ядра сервера. <br> 
  Команда Docker run используется для создания контейнеров, запускаемыми с использованием образов Docker <br> 
 </details>
<details>
  <summary>Что такое Dockerfile?</summary><br> 
  Dockerfile содержит инструкции для сборки образов, которые передаются в Docker. Текстовый документ, содержащий все возможные команды, с помощью которых пользователь, последовательно их запуская, может собрать образ<br> 
 </details>
<details>
  <summary> Расскажите о CMD и ENTRYPOINT в Dockerfile</summary><br> 
  Эти инструкции Dockerfile задают команду, исполняемую при запуске контейнера. При их использовании есть несколько правил, например:</p>
      Должна быть минимум одна из них, CMD или ENTRYPOINT, в Dockerfile.<br> 
      Если контейнер используется как исполняемый файл — ENTRYPOINT должна быть определена.<br> 
      Если контейнер запускается с другими аргументами — CMD будет переопределена.<br> 
 </details>
<details>
  <summary>Можно ли контейнер запустить без демона docker?</summary><br> 
  Нет, напрямую запустить контейнер без демона Docker нельзя, поскольку демон Docker (или другой контейнерный движок) необходим для управления контейнерами.<br> 
  Однако вы можете использовать альтернативные технологии, такие как containerd, как самостоятельную среду выполнения, с помощью клиентских инструментов вроде nerdctl для создания и запуска контейнеров без зависимости от демона Docker.<br> 
 </details>
<details>
  <summary> Kак связаны docker и kubernetes?</summary><br> 
   Тесно связаны: Docker создает и упаковывает приложения в контейнеры, а Kubernetes управляет и оркестрирует эти контейнеры в большом масштабе, автоматизируя их запуск, масштабирование и восстановление в кластере.  <br> 
   Kubernetes использует Docker как одну из возможных сред выполнения контейнеров, но также может работать с другими, такими как containerd и CRI-O. <br> 
</details>
<details>
  <summary>Как посмотреть текущую утилизацию контейнеров?</summary><br> 
  docker stats <br> 
</details>
<details>
  <summary>При ребилде образа сколько слоев получается?</summary><br> 
   При ребилде образа Docker получается столько слоев, сколько команд (инструкций) содержится в его Dockerfile, включая инструкции из базового образа. <br> 
  Каждый шаг в Dockerfile, такой как FROM, RUN, COPY, WORKDIR, создает новый слой, который представляет собой отдельный набор изменений файловой системы. <br> 
</details>
<details>
  <summary>Как перенести образ контейнера с одной машины на другую?</summary><br> 
   На одной машине выполнить команду сохранения образа в архив tar, а на другой сделать импорт<br>
   docker save -o someimage.tar <br>
   docker load -i someimage.tar <br>
</details>
<details>
  <summary>Как перенести данные контейнера с одной машины на другую? </summary><br> 
    export выгружает файловую систему созданного контейнера (не образ контейнера, а изменения, которые внес контейнер в образ) <br>
    import позволяет создать образ тома файловой системы из архива, созданного с помощью export <br>
    save/load относятся к данным образов, а export/import к данным контейнеров. <br>
</details> 
<details>
  <summary>Как остановить все контейнеры в докере? </summary><br> 
     docker stop $(docker ps -a -q)<br>
     docker rm $(docker ps -a -q)<br>
</details> 
<details>
  <summary>Как показать контейнеры по имени?  </summary><br> 
      docker ps --format '{{.Image}}'<br>
      docker ps --format Name:'{{.Names}}',Image:'{{.Image}}'<br>
</details>  
 


#### [[⬆]](#toc) <a name='openshift'>Вопросы по Kubernetes-Openshift</a>  
<details>
  <summary>Чем отличается Kubernetes от Openshift?</summary><br> 
      Openshift имеет более строгие политики безопасности и модели аутентификации.<br/>
      Openshift поддерживает полную интеграцию CI/CD Jenkins<br/>
      Openshift имеет веб-консоль по-умолчанию. В Kubernetes консоль необходимо дополнительно устанавливать консоль<br/>
      Kubernetes может быть установлен практически на любой дистрибутив Linux. Openshift имеет ограничения на устанавливаемые дистрибутивы, преимущественно используются RH-дистрибутивы.<br> 
      Kubernets доступен в большинстве облачных платформ - GCP, AWS, Azure, Yandex.Cloud. Openshift доступен на облачной платформе Azure и облаке от IBM.<br> 
</details>
<details>
  <summary>Чем отличаются ReplicationController от ReplicaSet?</summary><br> 
      ReplicationController гарантирует, что указанное количество реплик подов будут работать одновременно. Другими словами, ReplicationController гарантирует, что под или набор подов всегда активен и доступен.<br> 
      ReplicaSet - это следующее поколение Replication Controller. <br> 
</details>
<details>
  <summary>Если на каждой ноде Kubernetes кластера нужно запустить контейнер, то какой ресурс Kubernetes вам подойдет?</summary><br> 
     DaemonSet является контроллером, основным назначением которого является запуск подов на всех нодах кластера. Если нода добавляется/удаляется — DaemonSet автоматически добавит/удалит под на этой ноде. <br> 
     Например, с помощью него можно запустить поды с Prometheus Node Exporter для мониторинга, collectd или поды с fluentd or logstash для логирования узлов. <br> 
</details>
<details>
  <summary>В чем разница stateful и stateless?</summary><br> 
      Stateful-приложение — сохраняет данные при работе как состояние внутри себя. Примером могут быть сессии пользователей, которые хранятся на сервере. Ответ на запрос пользователя зависит от состояния сессии.<br/>
      Такие приложения сложнее масштабировать горизонтально: чтобы развернуть несколько экземпляров, нужно переносить состояния на новые машины и синхронизировать их.<br/>
      Stateless — любой запрос к приложению уникален, а его ответ не зависит от какого-либо состояния приложения. Stateless-приложения легко масштабируются горизонтально, упрощают автоматизированное тестирование, так как нет состояния, которое нужно воспроизводить. <br> 
</details>
<details>
    <summary>Какую функцию выполняет ReplicaSet?</summary><br> 
    ReplicaSet — позволяет поддерживать работу определенного количества экземпляров подов в кластере Kubernetes(используется для запуска Stateless-приложения). RS часто используется для обеспечения доступности приложения.     Если какие-то из подов покрашатся, то Kubernetes с помощью RS автоматически запускает новые экземпляры подов, чтобы заменить вышедшие из строя. Без RS пришлось бы их запускать вручную. <br> 
    Тем самым RS помогает сохранить приложение доступным для пользователей.<br> 
 </details>
<details>
    <summary>За что отвечает StatefulSet?</summary><br> 
    StatefulSet управляет развертыванием и масштабированием группы подов, но при этом он дает возможность сохранять состояние и характеристики подов. Например, если нужно, чтобы поды запускались в определенном порядке, на тех же нодах, чтобы при каждом запуске у каждого было хранилище (PVC) или какие-то специальные сетевые идентификаторы, используют StatefulSet <br/>
  Обычно он используется для запуска подов с очередями сообщений, брокеров и БД.<br> 
</details>
<details>
    <summary>Как поды разнести на разные ноды?</summary><br> 
    Необходимо настроить podAntiAffinity. Данное указание определяет, что для определенных подов следует использовать их размещание на разных нодах.<br> 
</details>
<details>
    <summary>В облаке есть 3 зоны доступности. Как сделать так, чтобы поды приложения распределились по этим зонам доступности равномерно?</summary><br> 
    Необходимо настроить podAntiAffinity. Либо, более новый вариант для данной задачи, настроить topologySpreadConstraints с указание ключа лейбла зон.<br> 
</details>
<details>
    <summary>Как контейнеры одного пода разнести на разные ноды?</summary><br> 
    Никак. Под - минимальная и неделимая сущность, Kubernetes оперирует подами, а не отдельными контейнерами.<br> 
</details>
<details>
    <summary>Как обеспечить, чтобы поды никогда не перешли в состояние Evicted на ноде?</summary><br> 
    Когда узлу (node) кластера не хватает памяти или дискового пространства, он активирует флаг, сигнализирующий о данной проблеме. Данное действие блокирует любое новое выделение ресурсов на ноде и запускает процесс "выселения" (evicted) пода с ноды.<br> 
    В этот момент kubelet начинает восстанавливать ресурсы, удаляя контейнеры и объявляя поды, как Failed, пока использование ресурсов снова не станет ниже порога "выселения".<br> 
    Сначала kubelet пытается освободить ресурсы узла, особенно диск, путем удаления мертвых модулей и их контейнеров, а затем неиспользуемых образов. <br> 
    Чтобы под не был удален при "выселении", необходимо настроить политики QoS для пода как Guaranteed.<br> 
</details> 
<details>
    <summary>Как в Kubernetes сделать приложение доступным извне по сети интернет?</summary><br> 
     ClusterIP — сущность, которая позволяет маршрутизировать запросы к подам на статичный IP-адрес.Благодаря ClusterIP у нас будет неизменная точка входа, даже если сами поды будут крашиться и восстанавливаться снова<br/>
     NodePort - делает сервис доступным извне через статический порт на каждом узле кластера. Любой трафик, отправленный на этот порт, будет перенаправлен на сервис. При этом ClusterIP создается автоматически.<br/>
     LoadBalancer - публикует сервис вовне и заводит трафик от балансировщика облачного провайдера внутрь кластера.<br/>
     External name - сопоставляет сервис с DNS-именем. Он создает CNAME-запись, которая соединяет DNS-имя с определенным именем внутри кластера. Выступает как прокси, которое позволяет пользователю перенаправлять запросы сервису, находящемуся внутри или за пределами кластера.<br> 
</details>
<details>
    <summary>Что такое ingress и зачем он нужен?</summary><br> 
     Ingress — это объект в Kubernetes, который управляет внешним доступом к сервисам внутри кластера.<br>  
     Он определяет правила маршрутизации входящего трафика (например, по URL или доменному имени) к нужным сервисам и позволяет выполнять такие функции, как балансировка нагрузки и SSL-терминация (шифрование/расшифровка данных).<br> 
    Он предоставляет единую точку входа для множества сервисов, упрощает управление трафиком и обеспечивает более безопасную и масштабируемую архитектуру. <br> 
</details>
<details>
    <summary>Что такое service?</summary><br> 
     Service — предоставляет IP-адрес и DNS-имя для группы подов (контейнеров с приложениями) и позволяет приложениям взаимодействовать друг с другом и с внешним миром без необходимости знать их динамические IP-адреса<br>
  Service обеспечивает балансировку нагрузки между подами, делая возможной замену или пересоздание подов без прерывания работы сервиса.<br>
</details>
<details>
    <summary>Какие типы сервисов бывают?</summary><br> 
     ClusterIP: Это тип по умолчанию, который делает сервис доступным для обмена данными внутри кластера. Пользователи вне кластера не могут получить доступ к сервису<br>  
     NodePort: Этот тип предоставляет каждому узлу в кластере Kubernetes порт, который перенаправляет трафик на сервис. Сервис становится доступным вне кластера по IP-адресу любого узла и порту, назначенному сервису<br>
     LoadBalancer: Этот тип автоматически создает внешний балансировщик нагрузки, если кластер Kubernetes запущен в облачной среде, поддерживающей балансировщики нагрузки. Балансировщик нагрузки перенаправляет внешний трафик на `NodePort`, который в свою очередь перенаправляет трафик на сервис <br>
    ExternalName: Этот тип позволяет сервису ссылаться на внешний сервис вне кластера по его DNS-имени<br>
</details>
<details>
    <summary>Объекты Istio в Kubernetes</summary><br> 
     <b> Это пользовательские ресурсы (Custom Resources, CRD), которые расширяют API Kubernetes и позволяют управлять поведением сервисной сетки (Service Mesh). </b> <br>
     <b> Эти объекты позволяют гибко управлять маршрутизацией запросов: VirtualService, DestinationRule, GateWay </b> <br>
</details>
<details>
    <summary>Какие минусы у кроновской джобы для шифта?</summary><br> 
    Основные недостатки <strong>Job и CronJob заключаются в сложности обработки сбоев</strong>, а также недостаточной надежности при высоких нагрузках, что требует применения Message Broker в качестве альтернативы для более сложных асинхронных сценариев.<br>
    Job - yaml-манифест, который создаёт под для выполнения разовой задачи. Если запуск задачи завершается с ошибкой, Job перезапускает поды до успешного выполнения или до истечения таймаутов. Когда задача выполнена, Job считается завершённым и больше никогда в кластере не запускается<br>
</details>


#### [[⬆]](#toc) <a name='elk'>Вопросы по Elastic'у</a>
<details>
    <summary>Что такое ELK-стек?</summary><br> 
    The Elastic Stack consists of:
     * Elasticsearch
     * Kibana
     * Logstash
     * Beats
     * Elastic Hadoop
     * APM Server <br> 
 </details> 
 
<details>
    <summary>Что такое "data node"?</summary><br> 
    <b> Это сервер, где хранятся данные, а также где происходит различная обработка (например, при поиске данных).</b><br> 
 </details>

<details>
    <summary>Что такое "master node"?</summary><br> 
    <b> Основные обязанности мастер ноды:
      * Отслеживать состояние всех узлов в кластере
      * Отслеживать состоянии каждой реплики, а также проверять, что данные доступны с каждого узла(data node).
      * Нет горячих узлов
      * Хотя может быть несколько главных узлов, на самом деле выбранным главным узлом является только один из них.
    </b><br> 
 </details>
 
 <details>
    <summary>Как данные сохраняются в Elasticsearch?</summary><br> 
* <b>Данные хранятся в индексе</b>
* <b> Индекс распределяется по кластеру с помощью шардирования</b><br> 
 </details>
 
 <details>
    <summary>Что такое индекс в Elasticsearch?</summary><br> 
      <b> Индекс можно рассматривать как оптимизированную коллекцию документов, и каждый документ представляет собой набор полей, которые представляют собой пары ключ-значение, содержащие ваши данные</b><br> 
 </details>

 <details>
    <summary>Что такое шард в Elasticsearch?</summary><br> 
      <b> Индекс разбивается на шарды, и документы хэшируются для определенного шарда. Шард может находиться на любом узле кластера, и представляет собой автономным индекс.Это позволяет легко масштабироваться до большого кластера серверов.</b><br> 
 </details>
 
<details>
    <summary>Как происходит заполнение пространства в кластере на нодах с дисками 1Тб, 2Тб, 3Тб?</summary><br> 
    <b> Кластер работает шардами, распределяя данные между нодами равномерно. Если на какой-то ноде места больше, оно не будет использовано для построения шарда. </b>     <br> 
 </details> 
 
<details>
    <summary>Какой оптимальный размер шарда?</summary><br> 
    <b> Нет абсолютной величины для этого правила. It depends. Вы можете эксперементировть на этот счет и выбрать оптимальный для ваших потребностей на основе данных и        запросов. Оф. документация говорит, что размер шарда должен быть в пределах от нескольких ГБ до нескольких десятков ГБ. </b> <br> 
 </details>
 

  

#### [[⬆]](#toc) <a name='fun'>Веселые вопросы:</a>

* <b>Админ случайно выполнил команду: ```chmod 444 /bin/chmod ```. Как починить?</b><br>
  Запустить загрузчик напрямую ```/lib/ld-linux.so /bin/chmod +x /bin/chmod```
  Восстановить разрешения с помощью busybox: ```busybox chmod +x /bin/chmod```
  Другие варианты: скопировать с другой системы; написать скрипт, который меняет разрешения. 
* <b>Вы забыли(потеряли) пароль рута, что делать? </b><br>
   Восстановить пароль рута можно с помощью Grub или LiveCD. <br>
* <b>Вы перезапустили удаленно сервер, но через 10 минут вы по-прежнему не можете к нему подключиться по SSH. В чем может быть проблема?</b><br>
  Нет проблемы с демоном SSH, проблема с командой reboot<br>
  Не выполняйте команду reboot now, выполняйте reboot или shutdown -r now для перезагрузки. <br>
  Человеческий фактор: изменен порт SSH, файервол заблокировал порт и т.д. <br>
* Вы застряли на необитаемом острове, какие 5 утилит командной строки вы бы выбрали?
* <b>Вы случайно удалали файл с запущенным скриптом, возможно ли его можно восстановить?</b><br>
   Пока скрипт запущен, файл восстановить можно с помощью procfs<br>
   Определите PID процесса, в директории /proc/$PID/fd будут находиться все дескрипторы, открытые этим процессом.<br>
   Далее просто копируете нужный: cp /proc/1234/fd/4 testing.txt.bk<br>
* <b>Что приозойдет 19 Января 2038?</b><br>
  На 32-х битных ОС, в которых используется представление времени по стандарту POSIX (UNIX-время), произойдет переход времени в 1970. <br>
  Чтобы этого не произошло нужно использовать 64-ую битную версию ОС. <br>
* <b>Как перегрузить сервер, если команда reboot  не отвечает?</b><br>
  Использовать команду ```shutdown```<br>
* <b>Чем отличается rest от json'a? <br /></b><br>
  Rest - архитектурный стиль взаимодействия компонентов распределённого приложения в сети.<br>
  SOAP - простой протокол доступа к объектам. Сейчас протокол используется для обмена произвольными сообщениями в формате XML.<br>
  REST поддерживает различные форматы: text, JSON, XML; SOAP - только XML<br>
* <b>Что произойдет если нажать TAB-TAB?</b><br>
  Все зависит от того, где вы находитесь, но в основном - автоподстановка.<br>

<a href="https://dev-engineer.blogspot.com/2019/10/linux_8.html"> Вопросы с ответами </a>

#### [[⬆]](#toc) <a name='web'>Сетевые вопросы:</a>
<details>
    <summary>Какую функцию выполняет DNS в сети?</summary><br> 
    <b> DNS — система для получения информации о доменах. Чаще всего используется для получения IP-адреса по имени хоста, получения информации о маршрутизации почты.</b> <br> 
 </details>
<details>
    <summary>Для чего используется протокол ARP?</summary><br> 
    <b> Протокол ARP (Address Resolution Protocol, Протокол разрешения адресов) используется для преобразования логических IP-адресов в физические MAC-адреса в локальных сетях (LAN), таких как Ethernet</b> <br> 
 </details>
<details>
    <summary>Что такое TLS</summary><br> 
    <b> TLS (Transport Layer Security, Протокол защиты транспортного уровня) — это криптографический протокол, который обеспечивает безопасную связь и передачу данных в компьютерных сетях, чаще всего в Интернете</b> <br> 
 </details>
<details>
    <summary>Что такое mTLS</summary><br> 
    <b>mTLS (mutual Transport Layer Security), или Взаимный TLS, — это расширенная версия стандартного протокола TLS, которая обеспечивает двустороннюю или взаимную аутентификацию обеих сторон соединения.
       В отличие от стандартного TLS (где только сервер подтверждает свою подлинность клиенту), при использовании mTLS и клиент, и сервер должны предоставить и проверить цифровые сертификаты друг друга перед установлением  безопасного соединения.</b> <br> 
 </details>
<details>
    <summary>В чём отличие TCP и UDP?</summary><br> 
    <b> TCP (Transmission Control Protocol) и UDP (User Datagram Protocol) — 2 основных транспортных протокола, используемых для передачи данных в сетях</b> <br>
    <b> 1. Установление соединения ("Рукопожатие") </b> <br>
    TCP требует предварительного "трехстороннего рукопожатия" (three-way handshake) перед началом передачи данных. Это гарантирует, что обе стороны готовы к обмену и знают о существовании друг друга.<br>
    UDP просто отправляет данные адресату без предварительной проверки или подтверждения готовности сервера.<br>
    <b>2. Надежность и гарантированная доставка</b> <br>
    TCP обеспечивает высокий уровень надежности. Если пакет потерян в пути, TCP автоматически обнаружит это и отправит его повторно. Он также гарантирует, что пакеты будут собраны в правильном порядке.<br>
    UDP не проверяет, дошел ли пакет до получателя. Он просто "выстреливает и забывает" (fire and forget). Если пакет потерян, приложение не будет знать об этом, если не реализует собственную проверку.<br>
    <b> 3. Скорость и производительность </b> <br>
    UDP значительно быстрее, так как у него нет задержек на установление соединения, подтверждения доставки и повторные отправки. Это идеально подходит для приложений, где важна скорость в реальном времени (например, голосовая связь или игры), и потеря нескольких пакетов не критична.<br>
    TCP медленнее из-за всех механизмов контроля надежности и большего объема служебной информации (накладных расходов).<br>
    Вывод<br>
    Используйте TCP, когда целостность и полнота данных критически важны (например, загрузка файла, открытие веб-страницы).<br>
    Используйте UDP, когда скорость имеет приоритет над 100% надежностью (например, стриминг видео, онлайн-игры).<br>
 </details>
<details>
    <summary>Какие записи ДНС вы знаете, для чего они используются?</summary><br> 
    <b> Записи DNS, или ресурсные записи (resource records), — единицы хранения и передачи информации в DNS.<br>
  Запись A (address record) или запись адреса связывает имя хоста с адресом протокола IPv4 <br>
  Запись AAAA (IPv6 address record) связывает имя хоста с адресом протокола IPv6.<br>
  Запись CNAME (canonical name record) или каноническая запись имени (псевдоним) используется для перенаправления на другое имя.<br>
  Запись MX (mail exchange) или почтовый обменник указывает сервер(ы) обмена почтой для данного домена.<br>
  Запись NS (name server) указывает на DNS-сервер для данного домена.<br>
  Запись PTR (pointer[5][6]) обратная DNS-запись или запись указателя связывает IP-адрес хоста с его каноническим именем.</b> <br> 
 </details>
  
* Что такое HTTP? <br>
  HTTP (от англ. HyperText Transfer Protocol — протокол передачи гипертекста) — это прикладной протокол передачи данных в сети.<br>
* Что такое HTTP-proxy и как он работает? <br>
  Сервер-посредник — промежуточный сервер в сети, выполняющий роль посредника между пользователем и целевым сервером, позволяющий клиентам как выполнять косвенные запросы (принимая и передавая их через прокси-сервер) к другим сетевым службам, так и получать ответы. Клиент подключается к прокси-серверу и запрашивает какой-либо ресурс, расположенный на другом сервере. Затем прокси-сервер либо подключается к указанному серверу и получает ресурс у него, либо возвращает ресурс из собственного кэша (в случаях, если прокси имеет свой кэш). <br>
* Кратко опишите как работает HTTPS.<br>
  HTTPS не является отдельным протоколом передачи данных, а представляет собой расширение протокола HTTP с надстройкой шифрования, т.к.
передаваемые по протоколу HTTP данные не защищены. <br>
* На каком уровне работает протокол HTTP? А протокол HTTPS? В чем различие HTTP и HTTPS<br>
  На прикладном уровне. <br>
  HTTPS (от англ. HyperText Transfer Protocol Secure — безопасный протокол передачи гипертекста) — это расширение протокола HTTP,   поддерживающее шифрование посредством криптографических протоколов SSL и TLS. HTTPS обеспечивает конфиденциальность информации путем ее шифрования. <br>
  HTTP использует порт 80, HTTPS — порт 443.<br>
* Кратко опишите действия по созданию и установке ssl-сертифката для сайта https://foo.example.com <br>
  1. Купить сертификат у проверенного центра авторизации или сгенерировать само подписанный
  2. В настройках вашего сервера включить поддержку ssl и указать путь к сертификату. <br>
* Можно ли использовать несколько SSL-хостов на одном айпи-адресе? <br>
  Да, с помощью веб-сервера это можно сделать. <br>
* Что такое wildcard сертификат?
  Wildcard-сертификат — сертификат открытого ключа, который может использоваться с несколькими поддоменами.
Например, один сертификат для *.example.com обеспечит домены payment.example.com, contact.example.com, login-secure.example.com <br>
* Что такое NAT, как он работает и зачем нужен?<br>
  NAT (Network Address Translation) – технология преобразовывания приватных IP-адресов во внешние в IPv4. Благодаря этому процессу ваша виртуальная машина получает доступ в Интернет. Механизм NAT как раз осуществляет подмену (или «маскировку») серых адресов на белые и наоборот. <br>
* На каком уровне коммуникационной модели OSI возможны сжатие и шифрование данных? <br>
  Уровень представления (англ. Presentation layer) — шестой уровень сетевой модели OSI. Этот уровень отвечает за преобразование протоколов и кодирование/декодирование данных. Запросы приложений, полученные с уровня приложений, он преобразует в формат для передачи по сети, а полученные из сети данные преобразует в формат, понятный приложениям.<br>
* Какие порты, согласно решению IANA, являются зарезервированными (Registered Ports)? <br>
  Зарегистрированными или пользовательскими портами являются 1024-49151 <br>
* Что такое TCP? <br>
  Transmission Control Protocol - Транспортный протокол передачи данных в сетях TCP/IP, предварительно устанавливающий соединение с сетью.<br>
* Что такое UDP? <br>
  User Datagram Protocol - Транспортный протокол, передающий сообщения-датаграммы без необходимости установки соединения в IP-сети. <br>
* Чем отличается TCP от UDP? <br>
  TCP исключает потери данных, дублирование и перемешивание пакетов, задержки. UDP все это допускает, и соединение для работы ему не требуется. <br>
* <b>Как проверить, что UDP-порт открыт?</b> <br>
  С помощью сканера портов или специальных утилит, например, iPerf <br>
* <b>Является ли айпи-адрес корректным 300.168.0.123?</b> <br>
  Нет, т.к. первый октет выход за 8-ми битные рамки.
* <b>Что такое SNMP и для чего он используется?</b><br>
  Стандарт SNMP (Simple Network Managment Protocol) был специально разработан для диагностики, управления и мониторинга любых устройств и программных компонентов, доступных по сетевым интерфейсам. <br>  
* What is localhost and why would ```ping localhost``` fail?
* What is the similarity between "ping" & "traceroute" ? How is traceroute able to find the hops.
* What is the command used to show all open ports and/or socket connections on a machine?
* Which IP ranges/subnets are "private" or "non-routable" (RFC 1918)?
* What is a VLAN?
* What is ARP and what is it used for?
* What is the purpose of a default gateway?
* What is command used to show the routing table on a Linux box?
* A TCP connection on a network can be uniquely defined by 4 things. What are those things?
* When a client running a web browser connects to a web server, what is the source port and what is the destination port of the connection?
* How do you add an IPv6 address to a specific interface?
* You have added an IPv4 and IPv6 address to interface eth0. A ping to the v4 address is working but a ping to the v6 address gives you the response ```sendmsg: operation not permitted```. What could be wrong?
* What is SNAT and when should it be used?
* Explain how could you ssh login into a Linux system that DROPs all new incoming packets using a SSH tunnel.
* How do you stop a DDoS attack?
* How can you see content of an ip packet?
* What is IPoAC (RFC 1149)?
* What will happen when you bind port 0?

#### [[⬆]](#toc) <a name='demo'>Практикум</a>

* В директории 500 файлов, необходимо найти все файлы свыше 20 ГБ, отсортировать по размеру, отобразить 5 самых больших файлов. <br> 
  find /data/ -size +20G | sort -r | tail -5 <br>
* Как разделить файл на несколько частей без архиватора? Например, 10 гб файл разделить по 1 гб. <br>
  Для этой цели подойдет команда split: split -b 1G somefile <br>
* Распакуйте test.tar.gz без использрования google и справки. <br>
  tar xvf test.tar.gz <br>
* Рекурсивно удалите все файлы с раширением "*.pyc" из тестовой директории? <br>
  find /testdir -type f -name '*.pyc' -delete <br>
* Найдите строку "my konfu is the best" во всех файлах с расширением *.py. <br>
  find / -type f -name '*.py' | grep -rnw -e 'my konfu is the best' <br>
  Grep options: <br>
   -r or -R включаем рекурсию <br>
   -n подсвечиваем номер строки <br>
   -w ищем точное совпадение <br>
* Замените вхождение фразы "my konfu is the best" на "I'm a linux jedi master" во всех *.txt файлах. <br>
  find / -type f -name '*.txt' | grep -rnw -e 'my konfu is the best' | sed -i 's/my konfu is the best/I'm a linux jedi master/g' * 
* Проверить доступность 443 порта на машине с IP-адресом X.X.X.X <br>
  telnet x.x.x.x 443
* Получить содержимое http://myinternal.webserver.local/test.html с помощью telnet'a. <br>
  telnet myinternal.webserver.local <br>
  GET /test.html <br>
* Отправить письмо используя командную строку(command line). <br>
  telnet mailserver.com 25 <br>
  HELO imfromthere.com <br>
  MAIL FROM: someaddress@imfromthere.com <br>
  RCPT TO: some@email.add <br>
  DATA Данные письма, конец письма заканчиваются '.' <br>
* Найти все файлы, которые использовались за последние 30 дней. <br>
  find . -type f -mtime -30 -printf "%M %u %g %TR %TD %p\n"
* Объясните следующую команду ```(date ; ps -ef | awk '{print $1}' | sort | uniq | wc -l ) >> Activity.log``` <br>
* Как узнать какой процесс запущен на определенном порту? <br>
  netstat -tunlp | grep portnumber
* Write a ```get_prim``` method in python/perl/bash/pseudo. <br>
* Write a script to list all the differences between two directories. <br>
* In a log file with contents as ```<TIME> : [MESSAGE] : [ERROR_NO] - Human readable text``` display summary/count of specific error numbers that occurred every hour or a specific hour. <br>
* <b>Напишите скрипт, чтобы посмотреть основную информацию о системе: hostname, IP адрес, залогинившихся пользователей, uptime, load average, статистику по оперативной памяти, подкачке и дисках.</b><br />
#!/bin/bash
hostname
hostname -I 
who
uptime
free
df -h	
<br>

#### [[⬆]](#toc) <a name='commands'>Команды:</a>
<details>
    <summary>KILL</summary><br> 
    <b> Команда kill используется для отправки сигналов процессам. Аргументы, которые используются вместе с kill, — это названия или номера сигналов, которые вы хотите отправить процессу.</b> <br> 
  <b> -15 "Вежливое" завершение работы, позволяет корректно завершить работу (например, сохранить файлы, закрыть соединения) и только потом выйти. </b> <br> 
  <b> -1   Перезапуск или переконфигурация, "перезагрузить конфигурацию без остановки приложения". </b> <br> 
  <b> -2   Прерывание выполнения. Тот же эффект, что и нажатие Ctrl+C в терминале. Приложение может обработать его и корректно завершиться. </b> <br> 
 </details>
 
* Какой командой можно посмотреть утилизацию памяти в Linux'e?<br />
  ```free -t -m ```<br>
* Какой командой осуществить поиск строки "my string" внутри директории рекурсивно?<br>
  grep -rn 'my string' <br>
* <b>Как посмотреть все файлы, включая скрытые в директории?</b><br>
  ls -la <br>
* <b>Какой командой можно удалить папку вместе со всем содержимым?</b><br>
  rm -fr <br>
* <b>Какой командой можно посмотреть все доступное место на диске Unix/Linux системы?</b><br>
  df -h</br>  
* <b>Какими командами можно проверить записи DNS?</b><br>
  host example.com <br /> nslookup example.com <br /> dig example.com<br />  
* <b>Вы запускаете скрипт и хотите посмотреть вывод в терминале и сохранить в файл, как это можно сделать?</b><br>
  Можно воспользоваться утилитой tee<br>
  ```./script | tee somefile.log```<br>  
* Что выполняют следующие команды?<br>
 * ```awk```
 * ```tr```
 * ```cut```
 * ```tac```
 * ```curl```
 * ```wget```
 * ```watch```
 * ```head```
 * ```tail```
 * ```less```
 * ```cat```
 * ```touch```
 * ```sar```
 * ```netstat```
 * ```tcpdump```
 * ```lsof```
 * ```cpio```
 * ```ps```
 * ```nohup```
 
 <a href="https://dev-engineer.blogspot.com/2019/11/linux_44.html"> Вопросы с ответами </a>
 
#### [[⬆]](#toc) <a name='references'>Other Great References:</a>

Другие интересные ссылки(некоторые вопросы были позаимствованы):

* https://github.com/darcyclarke/Front-end-Developer-Interview-Questions
* https://github.com/kylejohnson/linux-sysadmin-interview-questions/blob/master/test.md
* http://slideshare.net/kavyasri790693/linux-admin-interview-questions
* http://blog.sedicomm.com/2019/09/25/40-voprosov-dlya-sobesedovaniya-na-temu-linux/
